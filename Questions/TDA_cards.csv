Question,Option1,Option2,Option3,Option4,CorrectAnswer
Para que se ponen assertions en un codigo?,Para detectar errores de programación,Para detectar errores en el uso de los programas,Para detectar errores en el entorno de ejecución del programa,Para detectar errores producidos por el mal funcionamiento del hardware donde se ejecuta el programa,1
Que tipos de assertions son más útiles?,Las que verifican las precondiciones,Las que verifican las postcondiciones,Las que verifican las invariantes de bucle,Las que verifican invariantes de clase,1
Què vol dir que un algorisme té ordre exacte f(n)?,Que fa exactament f(n) operacions per un problema de mida n,Que la cota superior és d’ordre f(n),Que la cota inferior és d’ordre f(n),b) i c),4
Quina complexitat té el següent codi? \n int res=0; \n for (int i=0; i<1000: ++i) res=res+i;,O(4003),O(1000),O(1),O(0),3
Un algorisme greedy...,Divideix el problema en subproblemes que soluciona recursivament,"Selecciona un element en cada iteració i l’afegeix a la solució i, si en passos posteriors veu que s’ha equivocat, treu l’element de la solució",Selecciona un element en cada iteració i l’afegeix a la solució,"En cada iteració afegeix un element a cada conjunt possible, i al final selecciona el conjunt que és la solució,"3
Un algorisme greedy pot tenir una complexitat més petita que el cardinal del conjunt solució (O(n)),"Sí, pot tenir una complexitat O(log n)","Sí, pot tenir una complexitat O(1)","Sí, pot tenir una complexitat O(n!)","No, ja que tracta els n elements que formen la solució",4
En quins problemes d’optimització es pot aplicar la tècnica greedy per resoldre’ls?,Problemes pels quals fer una seqüència de passos òptims localment no assegura arribar a l’òptim global,Problemes on no es pot assegurar quina seqüència de decisions locals ens porta a la solució,Tots els problemes que es poden solucionar per backtracking,Problemes on la selecció óptima en cada pas porta a l’òptim global,4
Quin tipus de recursivitat té la funció següent? \n int f(int a) {\n   if (a>100) return a;\n    else {\n         int res=0;\n        for (int i=1; i<a; ++i) res=res+f(a*i);\n        return res;\n     }\n },Recursivitat simple,Recursivitat múltiple,Recursivitat final,Recursivitat indirecte,2
Quina de les següents funcions té recursivitat final?,int f(int n) { if (n==0) return n; else return f(n/2)+f(n/3); },int f(int n) { if (n==0) return n; else return 10*f(n/3); },int f(int n) { if (n==0) return n; else return f(n/3); },int f(int n) { if (n==0) return n; else return 10; },3
Quina complexitat té la següent funció considerant que n es positiu o 0? \n int f(n) { if (n==0) return 1; else return f(n/2)+f(n/2); },O(log2n),O(n),O(2^n),O(n^2),2
Quina diferència hi ha entre l’especificació d’un algorisme i l’algorisme?,L’especificació indica els passos que s’han d’executar i l’algorisme és la seva implementació,L’especificació ja indica com resoldre un problema i l’algorisme ho fa,L’especificació diu què ha de fer l’algorisme i l’algorisme diu com fer-ho,L’algorisme diu què ha de fer l’especificació i l’especificació diu com fer-ho,3
On podem posar les precondicions a un programa?,A l’inici de qualsevol part de codi que implementa un algorisme,a) i a l’inici de les funcions,al final de qualsevol part de codi que implementa un algorisme,c) i al final de les funcions,2
Com hem de tractar els trencaments de contracte?,Els trencaments de contracte que només es poden produir per error d’implementació es tracten amb assercions,"Els trencaments de contracte que només es poden produir per error en l’ús d’un programa es tracten amb tractament estructurat d’excepcions (try catch, throw)",a) i b),"Els trencaments de contracte sempre es tracten amb tractament estructurat d’excepcions (try catch, throw)",3
Quins tipus de complexitat es poden definir per un algorisme?,"Cota superior, cota inferior, ordre exacte i complexitat mitja o cas mig","Cota superior i cota inferior","Cota superior, cota inferior i complexitat mitja o cas mig","Cota superior, cota inferior i ordre exacte",1
"Com serà la complexitat pel pitjor dels casos d’un algorisme amb paràmetres x, y que especifiquen la mida del problema?","Serà una funció f(n) que per un n més gran que un n0 compleix que per una constant c, c*f(n) és més gran que el número d’operacions que fa l’algorisme","Serà una funció f(x,y) que per uns x, y més grans que uns x0, y0 compleix que per una constat c, c*f(x, y) és més gran que el número d’operacions que fa l’algorisme","Serà una funció f(n) que per un n més gran que un n0 compleix f(n) és més gran que el número d’operacions que fa l’algorisme","Serà una funció f(x,y) que compleix que per una constant c, c*f(x,y) és més gran que el número d’operacions que fa l’algorisme",2
Quin és l’ordre correcte de les complexitats de la més petita a la més gran?,"Constant, logarítmica, lineal, polinòmica, exponencial i factorial","Constant, lineal, logarítmica, polinòmica, exponencial i factorial"
Quins són els elements d’un algorisme greedy,"El conjunt de candidats, funció solució i funció de selecció","Funció solució, funció de selecció, funció de factibilitat i funció objectiu","El conjunt de candidats, funció solució, funció de selecció, funció de factibilitat, funció objectiu i funció resultat","El conjunt de candidats, funció solució, funció de selecció, funció de factibilitat i funció objectiu",4
Els algorismes greedy...,Comencen amb un conjunt solució buit al qual afegirà un element per cada iteració de l’algorisme,Sempre donen solució òptima si existeix solució pel problema,Divideixen els problemes en dos subproblemes més simples quan no tenen solució trivial,Afegeixen i treuen elements del conjunt solució,1
La complexitat esperada per un algorisme greedy sol ser...,Logarítmica ja que són algoritmes molt eficients,Lineal o pitjor ja que han de fer una iteració per cada element que forma la solució,Exponencial ja que revisen totes les combinacions possibles,c) o complexitat factorial,2
"Quin tipus de recursivitat té la funció f? \nint f(x) {\n  if (x==0) return 1;\n  else {\n    int a=0;\n    for (int i=1; i<10; ++i) a=a+f(x-i);\n  }\n  return a;\n}","Recursivitat indirecta, lineal i final","Recursivitat directa, lineal i final",Recursivitat directa i múltiple,"Recursivitat directa, múltiple i final",3
"La funció f es pot escriure com una funció iterativa?\nint f(x,y) {\n  if (x==0) return y;\n  else f(x/2,y*10);\n}",No es pot escriure com funció iterativa ja que és recursiva,Es pot escriure com funció iterativa però necessita l’ús d’una pila,Es pot escriure com funció iterativa sense utilitzar una pila,Ja és una funció iterativa,3
"Quina complexitat té la funció f?\nint f(x) {\n  if (x==0) return 1;\n  else return f(x-1)+f(x-1);\n}",O(x^2),O(2x),O(2^x),O(2x!),3
Quina de les següents afirmacions es certa?,Un algorisme de divideix i venceràs divideix un problema en subproblemes i selecciona el subproblema a resoldre per obtenir la solució del problema gran," Un algorisme de redueix i venceràs divideix un problema en subproblemes, resolt els subproblemes i junta les solucions d’aquets per formar la solució del problema gran","Un algorisme de divideix i venceràs divideix un problema en subproblemes, resolt els subproblemes i selecciona la solució d’un dels subproblemes que serà la solució del problema gran","Un algorisme de redueix i venceràs divideix un problema en subproblemes i selecciona el subproblema a resoldre per obtenir la solució del problema gran",4
Quina complexitat té el següent algorisme?\nF(0 elements) → retorna 1;\nF(n elements) →\n    for (i=0; i<n*n; ++i) operació elemental;\n    return F(n/2 elements)+ F(n/2 elements);,⊝(n^2),⊝(n^2·log_2(n)),⊝(n·log_2(n)),⊝(n),1
"Quina complexitat tindrà un algorisme de divideix i venceràs que divideix el problema de mida n en quatre parts, cadascuna amb mida n/4 i que per dividir un problema de mida n i ajuntar les soluciones de les quatre parts fa n^2 operacions? Aplica el problema mestre per obtenir la solució",n^2,n·log_4(n),n^2·log_4(n),n^(log_4(4)),1
Quina complexitat podem esperar d’un algorisme que divideix els problemes en dues parts i que té prou amb calcular la solució d’una de les parts per obtenir el resultat del problema complet?,Logarítmica,Lineal,Polinòmica,Exponencial,1
Quin algorisme té complexitat més petita: merge sort o quick sort?,Merge sort i quick sort tenen complexitat O(n log n),Merge sort té complexitat O(n log n) i quick sort O(n^2),Merge sort té complexitat O(n log n) i quick sort n log n en el cas mitjà,b) i c),4
Quin efecte té posar asserts a un programa a l’hora de trobar errors de programació?,Apropar la detecció de l’error a la seva font,Evitar que l’usuari utilitzi malament el programa,Pararà l’execució del programa en el cas que es compleixi la condició dels asserts,El programa en versió release s’executarà més lentament perquè ha d’avaluar les condicions dels asserts,1
Com poden detectar el mal ús d’un programa?,Amb assercions,"Amb tractament estructurat d’excepcions (try catch, throw)",a) però només per les precondicions,a) però només per les postcondicions,2
Quin és l’ordre de les complexitats de la millor a la pitjor (a és una constant >1)?,"O(1), O(n), O(n^a), O(n!), O(a^n), O(n^n)","O(n), O(1), O(n^a), O(a^n), O(n^n), O(n!)","O(1), O(n), O(a^n), O(n^a), O(n!), O(n^n)","O(1), O(n), O(n^a), O(a^n), O(n!), O(n^n)",4
Per a què un programa es pugui escalar a treballar amb moltes dades ha de complir...,Que els algorismes que utilitza tinguin una complexitat baixa en el millor dels casos,Que els algorismes que utilitza tinguin una complexitat baixa en el cas mig,Que els algorismes que utilitza tinguin una complexitat baixa en el pitjor dels casos,No importa la complexitat dels algorismes que utilitza,3
Per què els algorismes greedy tenen problemes per solucionar problemes d’optimització?,L’enunciat de la pregunta és erroni. Són bons per resoldre problemes d’optimització per que exploren totes les possibilitats,Perquè només es poden aplicar a problemes que compleixin el principi d’optimitat de Bellman,Perquè es basen en prendre sempre la millor decisió només amb informació sobre la solució parcial que estan construint,Perquè es basen en prendre sempre la millor decisió amb informació global sobre la solució,3
Per què els algorismes greedy poden solucionar el problema de l’arbre de cobertura mínin d’un graf (minimum spanning tree)?,Perquè la selecció de l’aresta de mínim cost que es pugui afegir a l’arbre genera una seqüència de decisions òptima que segur que porta a solució,"a) és certa, però la raó és que substituir una aresta per una altra porta a un arbre que tindrà cost igual o més gran, ja que no es pot substituir per una aresta amb cost més petit","Seleccionar l’aresta de mínim cost que es pugui afegir a l’arbre genera vàries seqüències de decisions localment òptimes i al final s’ha de seleccionar la millor de totes","a) és certa, però la raó és que substituir una aresta per una altra amb cost més gran porta a crear un arbre que no recobrirà totes les arestes del graf",2
Quins algorismes recursius tenen millor complexitat en la majoria dels casos?,Recursivitat indirecta,Recursivitat directa,Recursivitat lineal,Recursivitat múltiple,3
Com podem convertir un algorisme recursiu en iteratiu?,En el cas d’un algorisme amb recursivitat final es pot transformar en un simple bucle,En el cas general utilitzant una pila,a) o b) segons el cas,b) o amb bucles niats pels algorismes amb recursivitat múltiple,3
Quina complexitat tenen els algorismes de redueix i venceràs?,O(log n),O(n log n),O(a^n) on a>1,O(n!),1
Com es comporten els algorismes de divideix i venceràs?,Van afegint un element a la solució en cada iteració,Divideixen el problema en dos o més subproblemes,La solució del problema la formen combinant les solucions de dos o més subproblemes,b) i c) excepte pels que redueixen el problema,4
